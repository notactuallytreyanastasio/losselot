<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Decision Graph - Losselot</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: system-ui, -apple-system, sans-serif; background: #0f0f1a; color: #eee; }

        .header {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            padding: 1rem 2rem;
            border-bottom: 1px solid #0f3460;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .header h1 { font-size: 1.5rem; display: flex; align-items: center; gap: 0.5rem; }
        .header h1::before { content: "üéØ"; }
        .header a { color: #00d9ff; text-decoration: none; font-size: 0.9rem; }
        .header a:hover { text-decoration: underline; }

        .container { display: flex; height: calc(100vh - 60px); }

        .sidebar {
            width: 320px;
            background: #16213e;
            border-right: 1px solid #0f3460;
            display: flex;
            flex-direction: column;
        }
        .sidebar-header {
            padding: 1rem;
            border-bottom: 1px solid #0f3460;
            background: #1a1a2e;
        }
        .sidebar-header h3 { font-size: 0.9rem; color: #888; text-transform: uppercase; letter-spacing: 1px; }

        .node-list {
            list-style: none;
            padding: 0.5rem;
            overflow-y: auto;
            flex: 1;
        }
        .node-item {
            padding: 0.75rem;
            margin: 0.25rem 0;
            background: #0f3460;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            border-left: 4px solid transparent;
        }
        .node-item:hover { background: #1a4b8c; transform: translateX(4px); }
        .node-item.selected { background: #1a4b8c; box-shadow: 0 0 0 2px #00d9ff; }
        .node-item.goal { border-left-color: #00ff88; }
        .node-item.decision { border-left-color: #ffcc00; }
        .node-item.option { border-left-color: #00d9ff; }
        .node-item.action { border-left-color: #ff6b6b; }
        .node-item.outcome { border-left-color: #a855f7; }
        .node-item.observation { border-left-color: #888; }

        .node-type {
            font-size: 0.65rem;
            text-transform: uppercase;
            opacity: 0.6;
            letter-spacing: 0.5px;
        }
        .node-title { font-weight: 500; margin-top: 0.25rem; font-size: 0.9rem; }
        .node-status {
            font-size: 0.7rem;
            opacity: 0.5;
            margin-top: 0.25rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }
        .node-status::before {
            content: "";
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #888;
        }
        .node-item[data-status="completed"] .node-status::before { background: #00ff88; }
        .node-item[data-status="active"] .node-status::before { background: #ffcc00; }
        .node-item[data-status="rejected"] .node-status::before { background: #ff6b6b; }

        .main { flex: 1; display: flex; flex-direction: column; overflow: hidden; }

        .stats {
            display: flex;
            gap: 0.75rem;
            padding: 1rem;
            background: #1a1a2e;
            border-bottom: 1px solid #0f3460;
        }
        .stat {
            background: linear-gradient(135deg, #16213e 0%, #0f3460 100%);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            text-align: center;
            min-width: 80px;
        }
        .stat-value { font-size: 1.5rem; font-weight: bold; color: #00d9ff; }
        .stat-label { font-size: 0.7rem; opacity: 0.6; text-transform: uppercase; letter-spacing: 0.5px; }

        .graph-container {
            flex: 1;
            background: radial-gradient(ellipse at center, #1a1a2e 0%, #0f0f1a 100%);
            position: relative;
            overflow: hidden;
        }
        #graph-svg { width: 100%; height: 100%; }

        .empty-state {
            text-align: center;
            padding: 4rem;
            color: #666;
        }
        .empty-state h3 { margin-bottom: 1rem; color: #888; }
        .empty-state code {
            display: block;
            background: #1a1a2e;
            padding: 1rem;
            border-radius: 6px;
            margin-top: 1rem;
            font-size: 0.85rem;
            color: #00d9ff;
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: #16213e;
            border: 1px solid #0f3460;
            border-radius: 8px;
            padding: 1rem;
            max-width: 350px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .tooltip.visible { opacity: 1; }
        .tooltip-type {
            font-size: 0.65rem;
            text-transform: uppercase;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            display: inline-block;
            margin-bottom: 0.5rem;
        }
        .tooltip-type.goal { background: rgba(0,255,136,0.2); color: #00ff88; }
        .tooltip-type.decision { background: rgba(255,204,0,0.2); color: #ffcc00; }
        .tooltip-type.option { background: rgba(0,217,255,0.2); color: #00d9ff; }
        .tooltip-type.action { background: rgba(255,107,107,0.2); color: #ff6b6b; }
        .tooltip-type.outcome { background: rgba(168,85,247,0.2); color: #a855f7; }
        .tooltip-type.observation { background: rgba(136,136,136,0.2); color: #888; }
        .tooltip-title { font-weight: 600; margin-bottom: 0.5rem; }
        .tooltip-desc { font-size: 0.85rem; color: #aaa; line-height: 1.5; }
        .tooltip-status { font-size: 0.75rem; color: #666; margin-top: 0.5rem; }

        /* Detail panel */
        .detail-panel {
            position: absolute;
            bottom: 1rem;
            left: 1rem;
            right: 1rem;
            background: rgba(22,33,62,0.95);
            border: 1px solid #0f3460;
            border-radius: 8px;
            padding: 1rem;
            backdrop-filter: blur(10px);
            display: none;
        }
        .detail-panel.visible { display: block; }
        .detail-panel h4 { color: #00d9ff; margin-bottom: 0.5rem; }
        .detail-panel p { font-size: 0.85rem; color: #aaa; }
        .detail-close {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: none;
            border: none;
            color: #666;
            cursor: pointer;
            font-size: 1.25rem;
        }

        /* Edge legend */
        .legend {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: rgba(22,33,62,0.9);
            border: 1px solid #0f3460;
            border-radius: 6px;
            padding: 0.75rem;
            font-size: 0.75rem;
        }
        .legend-title { color: #888; margin-bottom: 0.5rem; text-transform: uppercase; font-size: 0.65rem; }
        .legend-item { display: flex; align-items: center; gap: 0.5rem; margin: 0.25rem 0; }
        .legend-line { width: 20px; height: 3px; border-radius: 2px; }
        .legend-line.chosen { background: #00ff88; }
        .legend-line.rejected { background: #ff6b6b; }
        .legend-line.leads_to { background: #444; }
        .legend-line.requires { background: #ffcc00; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Decision Graph</h1>
        <a href="/">‚Üê Back to Analysis</a>
    </div>
    <div class="container">
        <div class="sidebar">
            <div class="sidebar-header">
                <h3>Nodes</h3>
            </div>
            <ul class="node-list" id="nodeList"></ul>
        </div>
        <div class="main">
            <div class="stats" id="stats"></div>
            <div class="graph-container">
                <svg id="graph-svg"></svg>
                <div class="legend">
                    <div class="legend-title">Edge Types</div>
                    <div class="legend-item"><div class="legend-line chosen"></div> Chosen</div>
                    <div class="legend-item"><div class="legend-line rejected"></div> Rejected</div>
                    <div class="legend-item"><div class="legend-line leads_to"></div> Leads to</div>
                    <div class="legend-item"><div class="legend-line requires"></div> Requires</div>
                </div>
                <div class="detail-panel" id="detailPanel">
                    <button class="detail-close" onclick="hideDetail()">&times;</button>
                    <h4 id="detailTitle"></h4>
                    <p id="detailDesc"></p>
                </div>
            </div>
        </div>
    </div>
    <div class="tooltip" id="tooltip"></div>

    <script>
        var globalNodes = [];
        var globalEdges = [];

        async function loadGraph() {
            try {
                var res = await fetch('/api/graph');
                var json = await res.json();
                if (json.ok) {
                    globalNodes = json.data.nodes || [];
                    globalEdges = json.data.edges || [];
                    renderGraph();
                }
            } catch (e) {
                console.error('Failed to load graph:', e);
            }
        }

        function renderGraph() {
            var nodes = globalNodes;
            var edges = globalEdges;

            // Stats
            var statsEl = document.getElementById('stats');
            var typeCounts = {};
            nodes.forEach(function(n) { typeCounts[n.node_type] = (typeCounts[n.node_type] || 0) + 1; });

            statsEl.innerHTML =
                '<div class="stat"><div class="stat-value">' + nodes.length + '</div><div class="stat-label">Nodes</div></div>' +
                '<div class="stat"><div class="stat-value">' + edges.length + '</div><div class="stat-label">Edges</div></div>' +
                '<div class="stat"><div class="stat-value">' + (typeCounts.goal || 0) + '</div><div class="stat-label">Goals</div></div>' +
                '<div class="stat"><div class="stat-value">' + (typeCounts.decision || 0) + '</div><div class="stat-label">Decisions</div></div>' +
                '<div class="stat"><div class="stat-value">' + (typeCounts.action || 0) + '</div><div class="stat-label">Actions</div></div>';

            // Node list with descriptions
            var listEl = document.getElementById('nodeList');
            if (nodes.length === 0) {
                listEl.innerHTML = '<div class="empty-state"><h3>No decisions recorded yet</h3><p>Start tracking decisions with:</p><code>make goal T="Your goal"<br>make decision T="Choose approach"</code></div>';
            } else {
                var html = '';
                nodes.forEach(function(n) {
                    html += '<li class="node-item ' + n.node_type + '" data-id="' + n.id + '" data-status="' + n.status + '" onclick="showDetail(' + n.id + ')">' +
                        '<div class="node-type">' + n.node_type + '</div>' +
                        '<div class="node-title">' + escapeHtml(n.title) + '</div>' +
                        '<div class="node-status">' + n.status + '</div>' +
                    '</li>';
                });
                listEl.innerHTML = html;
            }

            // SVG graph with hierarchical layout
            var svg = document.getElementById('graph-svg');
            if (nodes.length === 0) {
                svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#666">No graph data</text>';
                return;
            }

            var width = svg.clientWidth || 800;
            var height = svg.clientHeight || 500;
            var nodeRadius = 25;
            var levelHeight = 90;
            var padding = 80;

            // Build adjacency for hierarchical layout
            var children = {};
            var parents = {};
            nodes.forEach(function(n) { children[n.id] = []; parents[n.id] = []; });
            edges.forEach(function(e) {
                if (children[e.from_node_id]) children[e.from_node_id].push(e.to_node_id);
                if (parents[e.to_node_id]) parents[e.to_node_id].push(e.from_node_id);
            });

            // Find roots (nodes with no parents)
            var roots = nodes.filter(function(n) { return parents[n.id].length === 0; });
            if (roots.length === 0) roots = [nodes[0]];

            // Assign levels via BFS
            var levels = {};
            var visited = {};
            var queue = roots.map(function(r) { return { id: r.id, level: 0 }; });
            while (queue.length > 0) {
                var item = queue.shift();
                if (visited[item.id]) continue;
                visited[item.id] = true;
                levels[item.id] = item.level;
                (children[item.id] || []).forEach(function(childId) {
                    if (!visited[childId]) {
                        queue.push({ id: childId, level: item.level + 1 });
                    }
                });
            }

            // Group by level
            var levelGroups = {};
            var maxLevel = 0;
            nodes.forEach(function(n) {
                var lvl = levels[n.id] || 0;
                if (!levelGroups[lvl]) levelGroups[lvl] = [];
                levelGroups[lvl].push(n);
                maxLevel = Math.max(maxLevel, lvl);
            });

            // Position nodes
            var nodePositions = {};
            Object.keys(levelGroups).forEach(function(lvl) {
                var group = levelGroups[lvl];
                var y = padding + parseInt(lvl) * levelHeight;
                var totalWidth = width - padding * 2;
                group.forEach(function(n, i) {
                    var x = padding + (i + 0.5) * (totalWidth / group.length);
                    nodePositions[n.id] = { x: x, y: y, node: n };
                });
            });

            // Adjust SVG height
            var svgHeight = Math.max(height, padding * 2 + (maxLevel + 1) * levelHeight);
            svg.setAttribute('viewBox', '0 0 ' + width + ' ' + svgHeight);

            // Colors by type
            var colors = {
                goal: '#00ff88',
                decision: '#ffcc00',
                option: '#00d9ff',
                action: '#ff6b6b',
                outcome: '#a855f7',
                observation: '#888'
            };

            // Edge colors by type
            var edgeColors = {
                chosen: '#00ff88',
                rejected: '#ff6b6b',
                leads_to: '#444',
                requires: '#ffcc00',
                blocks: '#ff6b6b',
                enables: '#00d9ff'
            };

            // Build SVG content
            var svgContent = '<defs>';
            // Arrowhead markers for each edge type
            Object.keys(edgeColors).forEach(function(type) {
                svgContent += '<marker id="arrow-' + type + '" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto"><path d="M0,0 L0,6 L9,3" fill="' + edgeColors[type] + '"/></marker>';
            });
            svgContent += '</defs>';

            // Draw edges
            edges.forEach(function(e) {
                var from = nodePositions[e.from_node_id];
                var to = nodePositions[e.to_node_id];
                if (from && to) {
                    var color = edgeColors[e.edge_type] || '#444';
                    var marker = 'url(#arrow-' + (edgeColors[e.edge_type] ? e.edge_type : 'leads_to') + ')';

                    // Calculate control points for curved edges
                    var dx = to.x - from.x;
                    var dy = to.y - from.y;
                    var cx = from.x + dx * 0.5;
                    var cy = from.y + dy * 0.5;

                    // Offset start/end by node radius
                    var angle = Math.atan2(dy, dx);
                    var startX = from.x + Math.cos(angle) * nodeRadius;
                    var startY = from.y + Math.sin(angle) * nodeRadius;
                    var endX = to.x - Math.cos(angle) * (nodeRadius + 8);
                    var endY = to.y - Math.sin(angle) * (nodeRadius + 8);

                    var strokeWidth = e.edge_type === 'chosen' ? 3 : 2;
                    var dashArray = e.edge_type === 'rejected' ? '5,5' : 'none';

                    svgContent += '<line x1="' + startX + '" y1="' + startY + '" x2="' + endX + '" y2="' + endY + '" stroke="' + color + '" stroke-width="' + strokeWidth + '" stroke-dasharray="' + dashArray + '" marker-end="' + marker + '"/>';
                }
            });

            // Draw nodes
            nodes.forEach(function(n) {
                var pos = nodePositions[n.id];
                if (!pos) return;
                var color = colors[n.node_type] || '#666';
                var desc = n.description || '';

                // Node circle with glow effect
                svgContent += '<circle cx="' + pos.x + '" cy="' + pos.y + '" r="' + (nodeRadius + 5) + '" fill="' + color + '" opacity="0.2"/>';
                svgContent += '<circle cx="' + pos.x + '" cy="' + pos.y + '" r="' + nodeRadius + '" fill="' + color + '" opacity="0.9" class="node-circle" data-id="' + n.id + '" onmouseover="showTooltip(event, ' + n.id + ')" onmouseout="hideTooltip()" onclick="showDetail(' + n.id + ')"/>';

                // Node label (truncated)
                var label = n.title.length > 20 ? n.title.slice(0, 18) + '...' : n.title;
                svgContent += '<text x="' + pos.x + '" y="' + (pos.y + 4) + '" text-anchor="middle" fill="#000" font-size="10" font-weight="600" pointer-events="none">' + escapeHtml(label) + '</text>';

                // Node type badge below
                svgContent += '<text x="' + pos.x + '" y="' + (pos.y + nodeRadius + 15) + '" text-anchor="middle" fill="' + color + '" font-size="9" opacity="0.8" pointer-events="none">' + n.node_type.toUpperCase() + '</text>';
            });

            svg.innerHTML = svgContent;
        }

        function escapeHtml(str) {
            return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
        }

        function showTooltip(event, nodeId) {
            var node = globalNodes.find(function(n) { return n.id === nodeId; });
            if (!node) return;

            var tooltip = document.getElementById('tooltip');
            tooltip.innerHTML =
                '<div class="tooltip-type ' + node.node_type + '">' + node.node_type + '</div>' +
                '<div class="tooltip-title">' + escapeHtml(node.title) + '</div>' +
                (node.description ? '<div class="tooltip-desc">' + escapeHtml(node.description) + '</div>' : '') +
                '<div class="tooltip-status">Status: ' + node.status + '</div>';

            tooltip.style.left = (event.clientX + 15) + 'px';
            tooltip.style.top = (event.clientY + 15) + 'px';
            tooltip.classList.add('visible');
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.remove('visible');
        }

        function showDetail(nodeId) {
            var node = globalNodes.find(function(n) { return n.id === nodeId; });
            if (!node) return;

            document.getElementById('detailTitle').textContent = node.title;
            document.getElementById('detailDesc').textContent = node.description || 'No description provided.';
            document.getElementById('detailPanel').classList.add('visible');

            // Highlight in sidebar
            document.querySelectorAll('.node-item').forEach(function(el) {
                el.classList.toggle('selected', el.dataset.id == nodeId);
            });
        }

        function hideDetail() {
            document.getElementById('detailPanel').classList.remove('visible');
            document.querySelectorAll('.node-item').forEach(function(el) {
                el.classList.remove('selected');
            });
        }

        loadGraph();
    </script>
</body>
</html>
